<<<<<<<<<<修正>>>>>>>>>>>>>>>
第一引数の指定子が%の場合。
・[フィールド幅]の取扱方
-->文字数も含んだ全体の出力幅

・[精度]の取扱方
-->何が数値として入力されても出力は同じで1(=文字数)

・[フィールド幅]と[精度]の共存

・*の取扱方
-->[フィールド幅][精度]どちらでも取り扱う

・0の取扱方
-->0埋めが実行される

・-の取扱方
-->0よりも優先される

・[指定子]cとの相違点
------> 挙動は全て[指定子]cと同じ
				(%cでは精度がundefinedに対し%%ではdefined)
				(%cでは0がundefinedに対し%%ではdefined)


================(   フロー   )=========================
領域の確保
---->p = malloc[フィールド幅]

f.flag
1)何もない(f.flag == -1)
	---> p[0] = '%'
2)-が存在する(f.flag == 1)
	--->p[0~n] = ' '
		p[n] = '%'
3)0が存在する(f.flag == 0)
	--->p[0~n] = '0'
		p[0] = '%'

f.f_flag
あればフィールド幅として扱う。

f.p_flag
あれば精度として扱う　--->　無視する。
































<<<<<<<<<<<<<<<<<第一引数から構造体に必要な情報を取得・格納するための関数>>>>>>>>>>>>>>>>>
flag: [- or 0 or NOTHING]
		デフォルト(NOTHING) --> -1
		'-'(優先)　　　　　　--> 1
		'0'				  --> 0(精度が存在すれば無視される)
f-flag: [*の有無]
		デフォルト(NOTHING)		--> -1
		'*'					   --> 1

field:
		デフォルト(NOTHING)		--> -1
		数値				   --> 数値


p-flag: [*の有無]
		デフォルト(NOTHING)		--> -1
		'*'					   --> 1




precise: [.数値の有無]
		デフォルト(NOTHING)		--> -1
		'.数値'				   --> 数値

conversion:　[c, s, p, d, i, u, x, X, %]

------> flag		: <int>		(-1)[1, 0, -1]
		f-flag		: <int>		(-1)[-1, 1]
		field		: <int>		(-1)[-1, 数値]

		p-flag		: <int>		(-1)[-1, 1]

		precise		: <int>		(-1)[-1, 数値]
		conversion	: <char>	(c)[c, s, p, d, i, u, x, X, %]


_____________________________________________________
while文で一文字ずつ読み込む
	--->認識できる 　:構造体に格納してインクリメント
	--->認識できない :そのまま次の項目を確認

					を繰り返す。
____________________________________________________



get_structに引き渡すのは%以降の文字列である(%を含む)。




<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<取得した情報の取扱方>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
[[[[[[[[[[[[[[[[[[[[[[[[[[大枠のフロー]]]]]]]]]]]]]]]]]]]]]]]]]]

whileとwriteで一文字ずつ出現させる
<%[フラグ][最小フィールド幅][.精度]変換指定子>の処理結果を文字列として全体文に組み込む
-> %以後を処理する関数を作る(処理結果を文字列にして返す関数)
->　%以後を処理する関数から受け取った結果(文字列)を全体の文字列の一部として出力する
-> *の処理(if (f.f_flag == 1)) f.field = va_arg


[[[[[[[[[[[[[[[[[[[[[%が出現してからのフロー]]]]]]]]]]]]]]]]]]]]]

・何進数(あるいは文字列)で表記するのかを確定(数値部分の確定)
	---> itoaで変換する。

・精度の確定(フィールド幅との共存)
	-精度の数値が桁数より大きい場合
		・数		:[精度の数値]-[桁数]分の0を付けて出力
		・文字列	:[文字列]を出力
	-精度の数値が桁数より小さい場合
		・数		:[数]を出力
		・文字列	:[精度の数値]文字分を出力

	------>出力桁数の確定

・フィールド幅をどう埋めるのかの確定(精度で出力する値を決定してから)
	-半角スペース[出力]       -->半角スペースを[[フィールド幅]-[出力桁数]]個出力　
	-[出力]半角スペース       -->半角スペースを[[フィールド幅]-[出力桁数]]個出力
	-0(精度優先)[出力]       -->0を[[フィールド幅]-[出力桁数]]個出力


出力される全体の文字数について>>>>>>>>>>>>>
数　　	:	[文字列] [フィールド幅] [精度]　の中で桁数が最も大きいものが全体の文字数となる。
文字列	:	[[精度]と[文字列]の小さい方]と[フィールド幅]の大きい方。

===========>処理結果はmallocで確保した領域内に格納する。



/*
va_argという関数は値そのものではなく、アドレスを取り扱う関数である。
アドレスは8バイトである。
8バイトの型はlong long;


long long a = (long long)va_args(ap,char *);
#define va_arg(ap,t)  (*(*(t **)&ap)++)
printf (const char *s,...)
アドレスの値を返すのとポインター を進める
*s++
*s++ = *p++;
long long a = (long long)va_args(ap,char *);
*/

int main(void)
{
	char *st;
	char c;
	c = 'a';
	st = &c;
	printf("%p\n", st);
	printf("%p\n", &c);

	long long i;
	i = (long long) st;
	printf("%lld\n", i);
	printf("%s\n\n\n", into_hex(i, 0));

	printf("[%32p]\n", &c);
	//printf("[%32.20p]\n", &c);
	//printf("[%032p]\n", &c);
	printf("[%-32p]\n", &c);
}






<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<修正する箇所>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
・ヌル文字の挿入について

































処理順
%[フラグ][最小フィールド幅][.精度]変換指定子

1)		全ての情報を構造体の要素として取得する。
			・フラグ				:flag					数値(識別用数値(フラグ))
			・フィールド幅			:field					数値(実数値)--->有無も重要
			・精度					:precise				数値(実数値)
			・フォーマット指定子		:specific				文字列(type)

			・'＊'は存在するのか
			・'.'は存在するのか

			--------->　while分で一文字ずつチェックする。

						%が出てきたら次の文字に注視。(フラグ or フィールド幅 or 精度 or 変換指定子　は不明)

						%の直後に[-0.*]があればフラグとして認識。
							・フィールド幅の記入がなければ無効。
								|・-があれば左揃え(0と-が両方存在する場合は-を優先)。デフォルトの値を０としておいて-があれば1に変換する。
								|・0があれば(なければ半角スペース)ゼロで埋める。
							・.があれば次に登場する数値を精度として記録。.だけの時は.0と同意。負の数の場合は無しと同意。s変換では、文字列から出力される最大文字数を指定する。
							・*があればフィールド幅として記録。第二引数の数値を取得する。

						数値が入力されればフィールド幅として認識。

						.があれば次に登場する数値を精度として記録。
						.だけの時は.0と同意。負の数の場合は無しと同意。s変換では、文字列から出力される最大文字数を指定する。

						[cspdiuxX%]を変換指定子として認識する。
							・c : 文字						(char)
							・s : 文字列					(char *)
							・p : 16進数(ポインタ値)
							・d : 10進数					(int)
							・i : 10進数					(int)
							・u : 符号無し10進数			(unsigned int)
							・x : 符号無し16進数


2)		表示形式を決定(何進数なのか)して、数値の変換を行う。
			16進数での出力が必要であればintを16進数に変換する。

3)		何桁表示するのかを決定する
			・浮動小数点がない場合
				-不足分は先頭から0(または半角スペース)で埋める。
				-規定されたフィールド幅よりも入力された数値の桁数を優先する。
			・浮動小数点がある場合
				-不足分は接尾を0で埋める
				-規定された精度を入力された数値よりも優先させる。

4)		左右どちらに寄せるのかを決定する
			・右寄せにする(デフォルト)。
			・左寄せにする('-'がある場合)。

5)		数値は文字に変換する

6)		出力


どのような型で出力するのか
ゼロはどこに何個表示するのか
半角スペースは何個表示するのか





va_arg(last, type);
typeにint







表示順
%  ---->  フラグ  ---->  フィールド幅  ---->  精度  ---->　フォーマット指定子



登場する変換指定子とフラグ
・変換指定子
--> cspdiuxX%
・フラグ
--> -0.*


d, i :	int 引き数を符号付き 10 進表記に変換する。
		精度指定があれば、精度で指定した桁数は必ず出力される。
		変換後の値が 指定された桁数に足りない場合は、左側が 0 で埋められる。
		デフォルトの精度は 1 である。
		0 を表示しようとした時に、明示的に精度として 0 が指定されていると、 出力は空文字列となる。




printfに必要なこと
・フォーマット指定子に適合した数値への変換。
・フラグに適合した表示方法への適合。
・表示桁数への適合
・表示桁数・精度への適合(小数点以下)
・%の後ろにフォーマット指定子があることは確定できるが、その他のオプションがあるかは未確定である。


知りたいこと
・何進数で表記するのか
・小数点以下を何桁表記するのか
・0埋めは必要なのか
・0埋めはどこに必要なのか
・0埋めは何個必要なのか
・左右どちらに寄せるのか(半角スペースは左右のどちらに表示するか)





printf
各変換指定は，文字%によって導入され，変換指定子で終わります。
その間には，（この順番で）0個以上のフラグ，オプションの最小フィールド幅，オプションの精度，オプションの長さ修飾子があるかもしれません。
%[フラグ][最小フィールド幅][.精度]変換指定子

*長さはBonusの課題ないようなので、今は考慮しない。


フラグ
0				:	値をゼロで埋める。
-				:	変換値をフィールド境界で左揃えにする。
*				:	フィールド幅と精度で使用。
.				:	精度で使用。





フィールド幅
最小のフィールド幅を指定する 10進数の数値文字列 (文字列の最初の文字は ゼロ以外)。
本項目はオプションである。 変換された値の文字数がフィールド長よりも少ない場合、 フィールドの左側をスペースで埋める (左揃えのフラグがある場合は右側を埋める)。
10進数の文字列の代わりに "*" や "*m$" (m は 10進整数) を書くこともできる。
"*" と "*m$" はそれぞれ、次の引き数と m 番目の引き数をフィールド幅として 使うことを指定する (これらの引き数は int 型でなければならない)。
フィールド幅に負の数が指定された場合は、 '-' フラグと正の数のフィールド幅として扱われる。
フィールド幅が小さかったり指定がなかったりしても、フィールドが切り詰められる ことはない。
もし変換結果がフィールド幅よりも広かった場合、 フィールドは変換結果が入る幅に広げられる。






精度(.)
オプションである精度は、ピリオド ('.') とそれに続く10進数という 形式で指定する (10進数はオプション) 。

精度として '.' だけが指定された場合、 精度はゼロとみなされる。
精度が負の数だった場合、 精度は指定されなかったものとみなされる。
d, i, o, u, x, X 変換では、表示される最小の桁数を指定する。
a, A, e, E, f, F 変換では、小数点以下に表示される数字の桁数を指定する。
g と G 変換では、有効数字の最大桁数を指定する。
s と S 変換では、文字列から出力される最大文字数を指定する。

10進数の文字列の代わりに "*" や "*m$" (m は 10 進整数)を書くこともできる。
"*" と "*m$" はそれぞれ、次の引き数と m 番目の引き数を精度として 使うことを指定する (これらの引き数は int 型でなければならない)。





フォーマット指定子

csp　diuxX%

d, i			:	int 引き数を符号付き 10 進表記に変換する。
u, x, X			:	unsigned int 引き数を、 符号なし10進数 (u), 符号なし16進数 (x と X) に変換する。
c				:	int 引き数を unsigned char に変換して、その結果に対応する文字を出力する。
s				:	引き数は const char * 型で文字型の配列へのポインター (文字列へのポインター) であることが 期待されている。
					配列中の文字は、終端の ヌルバイト ('\0') が出てくるまで出力される (終端文字は出力されない)。
p				:	void * ポインター引き数を (%#x や %#lx のような) 16 進数で出力する。

%				:	%%によって％を出力する。



pについて
void*を引数として、16進数の数値(アドレス)を出力する。
void* : 汎用ポインタ。あらゆるポインタ型に変換可能。ポインタ型であればどのような型でも受け取ることができる。
--> ポインタであることは分かるが実際にどの型のポインタかは不明である。
--> charであってもintであっても、ポインタであるので数値ということに変わりない。
[1. アドレスを取得したい ----> 2. 16進数の数値として出力したい]










------------------------------------------------------------
printf("(1) %.10f\n", 123.43);           //////(1)
printf("(2) %*f\n",10, 123.43);          //////(2)
printf("(3) %10f\n", 123.43);            //////(3)

$ ./a.out
(1) 123.4300000000
(2) 123.430000
(3) 123.430000


結論：
精度(.を使用する)では、小数点以下の桁数を10出力する。すなわち、小数点以下の桁数を指定する。
フィールド幅とは小数点以下の数も全て含めた桁数の指定である。
------------------------------------------------------------
printf("(1) %.10d\n", 123);             //////(1)
printf("(2) %*d\n",10, 123);            //////(2)
printf("(3) %10d\n", 123);              //////(3)

$ ./a.out
(1) 0000000123
(2)        123
(3)        123

結論：
ここでの精度も表示桁数を示しているが小数点なしの場合は先頭から表示桁数を補完する形で0埋めされる。
フィールド幅の場合は0埋めはなく半角スペース埋めとなる。
-------------------------------------------------------------
printf("(1)%s\n", "apple");			////////(1)
printf("(2)[%.10s]\n", "apple");	////////(2)
printf("(3)[%10s]\n", "apple");		////////(3)
printf("(4)[%*s]\n", 10, "apple");	////////(4)
printf("(5)[%-10s]\n", "apple");	////////(4)

(1)apple
(2)[apple]
(3)[     apple]
(4)[     apple]
(5)[apple     ]

結論：
精度は取得できるが文字列を出力する段階では考慮されない。
一方、フィールド幅の指定には忠実に準拠する。
-------------------------------------------------------------






使用関数
// malloc
// free
// write
// va_start
// va_arg
// va_copy
// va_end

・write関数で標準出力できる方はcharに絞られる。







f_list get_struct(const char *st, int i)
{
	f_list f;

	ft_init_flag(f);

	while (st[i])
	{
		if (st[i] == '%')
		{
			i++;
			if (st[i] == '0')
			{
				f.flag = 0;
				i++;
			}
			if (st[i] == '-')
			{
				f.flag = 1;
				i++;
			}
			if (st[i] == '0')
				i++;
			if (st[i] == '*')
			{
				f.f_flag = 1;
				i++;
			}
			if (st[i] && st[i] >= '0' && st[i] <= '9')
			{
				f.field = get_number(&st[i]);
				i += get_digit(f.field);
			}
			if (st[i] == '.')
			{
				f.precise = 0;
				i++;
				if (st[i] == '*')
				{
					f.p_flag = 1;
					i++;
				}
				if (st[i] && st[i] >= '0' && st[i] <= '9')
				{
					f.precise = get_number(&st[i]);
					i += get_digit(f.precise);
				}
			}
			f.conversion = st[i];
		}
		i++;
	}
	return (f);
}